import{S as Yt,i as Zt,s as gt,k as s,a as p,y as Ft,M as er,l,h as t,c as m,m as i,z as Kt,n as B,E as r,b as f,A as Lt,g as Qt,d as Ut,B as Vt,q as a,r as o,F as Xt}from"../chunks/index.be4cd1eb.js";import{d as tr,b as rr,H as ar,C as or}from"../chunks/Content.02190510.js";function sr(U){let c,$;return{c(){c=s("h1"),$=a("Work")},l(h){c=l(h,"H1",{});var d=i(c);$=o(d,"Work"),d.forEach(t)},m(h,d){f(h,c,d),r(c,$)},p:Xt,d(h){h&&t(c)}}}function lr(U){let c,$,h,d,A,v,y,u,_,b,W,fe,S,V,ke,we,z,Be,Ae,pe,H,X,He,Re,me,R,Y,De,Ie,ce,N,Ce,ue,P,Z,Oe,xe,q,Ge,Te,J,We,ze,de,D,g,Ne,qe,he,I,ee,Je,Me,_e,M,je,be,E,te,Fe,Ke,j,Le,Qe,F,Ue,Ve,K,Xe,Ye,ve,C,re,Ze,ge,Ee,O,ae,et,tt,$e,L,rt,ye,k,oe,at,ot,Q,st,lt,Pe,x,se,nt,it,Se,G,le,ft,pt;return{c(){c=s("h2"),$=a("Employment"),h=p(),d=s("p"),A=a(`I work at Greenpeace International as a software engineer. I use my skills as a
            programmer and activist to increase the impact of Greenpeace.`),v=p(),y=s("h2"),u=a("Open Source"),_=p(),b=s("h3"),W=a("Peermerge"),fe=p(),S=s("p"),V=s("b"),ke=a("Description:"),we=p(),z=s("a"),Be=a("Peermerge"),Ae=a(` is a set of rust
            crates for managing peer-to-peer, multi-writer, JSON-like documents.`),pe=p(),H=s("p"),X=s("b"),He=a("Role:"),Re=a(" author and maintainer"),me=p(),R=s("p"),Y=s("b"),De=a("Status:"),Ie=a(" alpha"),ce=p(),N=s("h3"),Ce=a("Hypercore"),ue=p(),P=s("p"),Z=s("b"),Oe=a("Description:"),xe=p(),q=s("a"),Ge=a("hypercore"),Te=a(` and
            `),J=s("a"),We=a("hypercore-protocol"),ze=a(` are rust
            crates that implement a secure, distributed append-only feed, and a peer-to-peer protocol,
            respectively.`),de=p(),D=s("p"),g=s("b"),Ne=a("Role:"),qe=a(" co-author and maintainer"),he=p(),I=s("p"),ee=s("b"),Je=a("Status:"),Me=a(" beta"),_e=p(),M=s("h3"),je=a("Random Access Storage"),be=p(),E=s("p"),te=s("b"),Fe=a("Description:"),Ke=p(),j=s("a"),Le=a("random-access-storage"),Qe=a(`,
            `),F=s("a"),Ue=a("random-access-disk"),Ve=a(`, and ,
            `),K=s("a"),Xe=a("random-access-memory"),Ye=a(` are rust
            crates that implement reading and writing at random offsets to a disk or memory storage.`),ve=p(),C=s("p"),re=s("b"),Ze=a("Role:"),ge=a(" co-author and maintainer"),Ee=p(),O=s("p"),ae=s("b"),et=a("Status:"),tt=a(" released"),$e=p(),L=s("h3"),rt=a("Compact Encoding"),ye=p(),k=s("p"),oe=s("b"),at=a("Description:"),ot=p(),Q=s("a"),st=a("compact-encoding"),lt=a(` is a rust crate
            for building small and fast parsers and serializers.`),Pe=p(),x=s("p"),se=s("b"),nt=a("Role:"),it=a(" author and maintainer"),Se=p(),G=s("p"),le=s("b"),ft=a("Status:"),pt=a(" released"),this.h()},l(e){c=l(e,"H2",{});var n=i(c);$=o(n,"Employment"),n.forEach(t),h=m(e),d=l(e,"P",{});var Et=i(d);A=o(Et,`I work at Greenpeace International as a software engineer. I use my skills as a
            programmer and activist to increase the impact of Greenpeace.`),Et.forEach(t),v=m(e),y=l(e,"H2",{});var $t=i(y);u=o($t,"Open Source"),$t.forEach(t),_=m(e),b=l(e,"H3",{});var yt=i(b);W=o(yt,"Peermerge"),yt.forEach(t),fe=m(e),S=l(e,"P",{});var ne=i(S);V=l(ne,"B",{});var Pt=i(V);ke=o(Pt,"Description:"),Pt.forEach(t),we=m(ne),z=l(ne,"A",{href:!0});var St=i(z);Be=o(St,"Peermerge"),St.forEach(t),Ae=o(ne,` is a set of rust
            crates for managing peer-to-peer, multi-writer, JSON-like documents.`),ne.forEach(t),pe=m(e),H=l(e,"P",{});var mt=i(H);X=l(mt,"B",{});var kt=i(X);He=o(kt,"Role:"),kt.forEach(t),Re=o(mt," author and maintainer"),mt.forEach(t),me=m(e),R=l(e,"P",{});var ct=i(R);Y=l(ct,"B",{});var wt=i(Y);De=o(wt,"Status:"),wt.forEach(t),Ie=o(ct," alpha"),ct.forEach(t),ce=m(e),N=l(e,"H3",{});var Bt=i(N);Ce=o(Bt,"Hypercore"),Bt.forEach(t),ue=m(e),P=l(e,"P",{});var T=i(P);Z=l(T,"B",{});var At=i(Z);Oe=o(At,"Description:"),At.forEach(t),xe=m(T),q=l(T,"A",{href:!0});var Ht=i(q);Ge=o(Ht,"hypercore"),Ht.forEach(t),Te=o(T,` and
            `),J=l(T,"A",{href:!0});var Rt=i(J);We=o(Rt,"hypercore-protocol"),Rt.forEach(t),ze=o(T,` are rust
            crates that implement a secure, distributed append-only feed, and a peer-to-peer protocol,
            respectively.`),T.forEach(t),de=m(e),D=l(e,"P",{});var ut=i(D);g=l(ut,"B",{});var Dt=i(g);Ne=o(Dt,"Role:"),Dt.forEach(t),qe=o(ut," co-author and maintainer"),ut.forEach(t),he=m(e),I=l(e,"P",{});var dt=i(I);ee=l(dt,"B",{});var It=i(ee);Je=o(It,"Status:"),It.forEach(t),Me=o(dt," beta"),dt.forEach(t),_e=m(e),M=l(e,"H3",{});var Ct=i(M);je=o(Ct,"Random Access Storage"),Ct.forEach(t),be=m(e),E=l(e,"P",{});var w=i(E);te=l(w,"B",{});var Ot=i(te);Fe=o(Ot,"Description:"),Ot.forEach(t),Ke=m(w),j=l(w,"A",{href:!0});var xt=i(j);Le=o(xt,"random-access-storage"),xt.forEach(t),Qe=o(w,`,
            `),F=l(w,"A",{href:!0});var Gt=i(F);Ue=o(Gt,"random-access-disk"),Gt.forEach(t),Ve=o(w,`, and ,
            `),K=l(w,"A",{href:!0});var Tt=i(K);Xe=o(Tt,"random-access-memory"),Tt.forEach(t),Ye=o(w,` are rust
            crates that implement reading and writing at random offsets to a disk or memory storage.`),w.forEach(t),ve=m(e),C=l(e,"P",{});var ht=i(C);re=l(ht,"B",{});var Wt=i(re);Ze=o(Wt,"Role:"),Wt.forEach(t),ge=o(ht," co-author and maintainer"),ht.forEach(t),Ee=m(e),O=l(e,"P",{});var _t=i(O);ae=l(_t,"B",{});var zt=i(ae);et=o(zt,"Status:"),zt.forEach(t),tt=o(_t," released"),_t.forEach(t),$e=m(e),L=l(e,"H3",{});var Nt=i(L);rt=o(Nt,"Compact Encoding"),Nt.forEach(t),ye=m(e),k=l(e,"P",{});var ie=i(k);oe=l(ie,"B",{});var qt=i(oe);at=o(qt,"Description:"),qt.forEach(t),ot=m(ie),Q=l(ie,"A",{href:!0});var Jt=i(Q);st=o(Jt,"compact-encoding"),Jt.forEach(t),lt=o(ie,` is a rust crate
            for building small and fast parsers and serializers.`),ie.forEach(t),Pe=m(e),x=l(e,"P",{});var bt=i(x);se=l(bt,"B",{});var Mt=i(se);nt=o(Mt,"Role:"),Mt.forEach(t),it=o(bt," author and maintainer"),bt.forEach(t),Se=m(e),G=l(e,"P",{});var vt=i(G);le=l(vt,"B",{});var jt=i(le);ft=o(jt,"Status:"),jt.forEach(t),pt=o(vt," released"),vt.forEach(t),this.h()},h(){B(z,"href","https://codeberg.org/convivialsoftware/peermerge"),B(q,"href","https://github.com/datrs/hypercore"),B(J,"href","https://github.com/datrs/hypercore-protocol-rs"),B(j,"href","https://github.com/datrs/random-access-storage"),B(F,"href","https://github.com/datrs/random-access-disk"),B(K,"href","https://github.com/datrs/random-access-memory"),B(Q,"href","https://github.com/datrs/compact-encoding")},m(e,n){f(e,c,n),r(c,$),f(e,h,n),f(e,d,n),r(d,A),f(e,v,n),f(e,y,n),r(y,u),f(e,_,n),f(e,b,n),r(b,W),f(e,fe,n),f(e,S,n),r(S,V),r(V,ke),r(S,we),r(S,z),r(z,Be),r(S,Ae),f(e,pe,n),f(e,H,n),r(H,X),r(X,He),r(H,Re),f(e,me,n),f(e,R,n),r(R,Y),r(Y,De),r(R,Ie),f(e,ce,n),f(e,N,n),r(N,Ce),f(e,ue,n),f(e,P,n),r(P,Z),r(Z,Oe),r(P,xe),r(P,q),r(q,Ge),r(P,Te),r(P,J),r(J,We),r(P,ze),f(e,de,n),f(e,D,n),r(D,g),r(g,Ne),r(D,qe),f(e,he,n),f(e,I,n),r(I,ee),r(ee,Je),r(I,Me),f(e,_e,n),f(e,M,n),r(M,je),f(e,be,n),f(e,E,n),r(E,te),r(te,Fe),r(E,Ke),r(E,j),r(j,Le),r(E,Qe),r(E,F),r(F,Ue),r(E,Ve),r(E,K),r(K,Xe),r(E,Ye),f(e,ve,n),f(e,C,n),r(C,re),r(re,Ze),r(C,ge),f(e,Ee,n),f(e,O,n),r(O,ae),r(ae,et),r(O,tt),f(e,$e,n),f(e,L,n),r(L,rt),f(e,ye,n),f(e,k,n),r(k,oe),r(oe,at),r(k,ot),r(k,Q),r(Q,st),r(k,lt),f(e,Pe,n),f(e,x,n),r(x,se),r(se,nt),r(x,it),f(e,Se,n),f(e,G,n),r(G,le),r(le,ft),r(G,pt)},p:Xt,d(e){e&&t(c),e&&t(h),e&&t(d),e&&t(v),e&&t(y),e&&t(_),e&&t(b),e&&t(fe),e&&t(S),e&&t(pe),e&&t(H),e&&t(me),e&&t(R),e&&t(ce),e&&t(N),e&&t(ue),e&&t(P),e&&t(de),e&&t(D),e&&t(he),e&&t(I),e&&t(_e),e&&t(M),e&&t(be),e&&t(E),e&&t(ve),e&&t(C),e&&t(Ee),e&&t(O),e&&t($e),e&&t(L),e&&t(ye),e&&t(k),e&&t(Pe),e&&t(x),e&&t(Se),e&&t(G)}}}function nr(U){let c,$,h,d,A,v,y;return d=new ar({props:{$$slots:{default:[sr]},$$scope:{ctx:U}}}),v=new or({props:{$$slots:{default:[lr]},$$scope:{ctx:U}}}),{c(){c=s("meta"),$=p(),h=s("section"),Ft(d.$$.fragment),A=p(),Ft(v.$$.fragment),this.h()},l(u){const _=er("svelte-odjrod",document.head);c=l(_,"META",{name:!0,content:!0}),_.forEach(t),$=m(u),h=l(u,"SECTION",{});var b=i(h);Kt(d.$$.fragment,b),A=m(b),Kt(v.$$.fragment,b),b.forEach(t),this.h()},h(){document.title="Work | Timo Tiuraniemi",B(c,"name","description"),B(c,"content","What I'm working on currently")},m(u,_){r(document.head,c),f(u,$,_),f(u,h,_),Lt(d,h,null),r(h,A),Lt(v,h,null),y=!0},p(u,[_]){const b={};_&1&&(b.$$scope={dirty:_,ctx:u}),d.$set(b);const W={};_&1&&(W.$$scope={dirty:_,ctx:u}),v.$set(W)},i(u){y||(Qt(d.$$.fragment,u),Qt(v.$$.fragment,u),y=!0)},o(u){Ut(d.$$.fragment,u),Ut(v.$$.fragment,u),y=!1},d(u){t(c),u&&t($),u&&t(h),Vt(d),Vt(v)}}}const pr=tr,mr=rr;class cr extends Yt{constructor(c){super(),Zt(this,c,null,nr,gt,{})}}export{cr as default,pr as hydrate,mr as router};
